# Day 6: First AWS Infrastructure Build - S3 + CloudFront Static Website
**Date:** October 18, 2025 (Saturday)
**Time:** 30 minutes (build) + 20 minutes (CloudFront deployment wait) + documentation
**Focus:** Hands-on AWS - Building production-grade static website infrastructure

## Project Overview

Today I deployed my first real AWS infrastructure - a static website hosted on S3 with CloudFront distribution for global content delivery. This is a foundational Solutions Architect pattern used by companies serving millions of users. The website is live and accessible to anyone in the world at https://d3sow6jxmgyxlc.cloudfront.net/

This project marks the transition from learning theory to building actual cloud infrastructure. After five days of foundational skills (terminal navigation, Python basics, GitHub workflow), today I applied that knowledge to create production-grade AWS resources.

## Architecture Built

**Components:**
- S3 bucket for static website hosting (origin)
- CloudFront distribution for global content delivery (CDN)
- Bucket policy for public read access (IAM)
- HTTPS security through CloudFront SSL certificate

**Data Flow:**
User requests website → CloudFront edge location (nearest to user) → Cached content served immediately OR → Fetch from S3 bucket in us-east-2 → Cache at edge location → Serve to user

## Build Process

### Phase 1: S3 Static Website Setup

Created a simple HTML file locally with basic content indicating this is Day 6 of my AWS journey. The HTML was intentionally minimal for this first iteration - just enough to verify the architecture works. I can always enhance the content later once I understand the infrastructure.

Created an S3 bucket with globally unique name `chris-aws-journey-2025` in the us-east-2 Ohio region. AWS requires bucket names to be globally unique across all of AWS, not just within your account. During creation, I had to explicitly disable the "Block all public access" setting because the default AWS security posture is to keep buckets private. This is good for security in general but doesn't work for public websites.

Uploaded the index.html file to the bucket. At this point, the file existed in S3 but wasn't accessible as a website yet.

Enabled static website hosting in the bucket properties, specifying index.html as the index document. This tells S3 to act as a web server rather than just file storage. After enabling this, I received an S3 website endpoint URL: http://chris-aws-journey-2025.s3-website.us-east-2.amazonaws.com/

The critical step that many people miss is the bucket policy. Even though I'd disabled "Block all public access," that only removes the blanket restriction - it doesn't actually grant permission to read the files. I needed to create a bucket policy with JSON that explicitly allows public GetObject access. The policy uses five key components that I'm remembering with the acronym SEPAR (Separate Every Pizza At Rest):
- **S**id: Statement identifier 
- **E**ffect: Allow or Deny
- **P**rincipal: Who the policy applies to (in this case, `*` meaning everyone)
- **A**ction: What actions are permitted (s3:GetObject for reading files)
- **R**esource: Which resources the policy applies to (all objects in my bucket)

After configuring the bucket policy correctly, the S3 website URL loaded successfully in my browser. Phase 1 complete.

### Phase 2: CloudFront Distribution

Created a CloudFront distribution pointing to my S3 website endpoint as the origin. It's important to use the S3 website endpoint (the one with s3-website in the URL) rather than the regular bucket endpoint, because the website endpoint respects static website hosting configurations like index documents.

Key configurations I set:
- Viewer protocol policy: Redirect HTTP to HTTPS (enforces secure connections)
- Compress objects automatically: Enabled (free performance improvement)
- Cache policy: CachingOptimized (designed for static websites)
- Price class: Use all edge locations (maximum global coverage)
- Default root object: index.html

CloudFront assigned my distribution the domain name d3sow6jxmgyxlc.cloudfront.net and began deploying to edge locations globally. This deployment process took approximately 15-20 minutes, which is normal as the configuration propagates to over 200 edge locations across six continents.

Once deployment completed and the status showed "Enabled," the website was accessible via the CloudFront URL with HTTPS security. Same content as the S3 URL, but now served through a global CDN with encryption.

## Key Learnings

### Dual-Layer Permission Model

S3 security works on two levels that both must be configured correctly. First, you disable the blanket "Block all public access" setting which removes the account-level restriction. Second, you create a bucket policy that explicitly grants public read permissions. Having one without the other doesn't work - you need both layers configured properly. This caught me initially when I was working through the permissions logic, and it's apparently where most people get stuck on their first S3 website build.

### S3 vs CloudFront: Understanding the Difference

My S3 URL (http://chris-aws-journey-2025.s3-website.us-east-2.amazonaws.com/) serves content directly from the bucket in Ohio over insecure HTTP. My CloudFront URL (https://d3sow6jxmgyxlc.cloudfront.net/) serves the same content through a global content delivery network over secure HTTPS.

CloudFront provides several advantages over direct S3 access:

**Reduced latency through edge caching:** When a user in Japan requests my website, CloudFront serves it from the Tokyo edge location rather than forcing the request to travel to Ohio and back. The first user to request the content from a region fetches it from S3, but subsequent users get it from the cached version at the edge. This dramatically reduces load times globally.

**HTTPS security:** CloudFront provides SSL/TLS encryption automatically using AWS-managed certificates. The S3 website endpoint only supports HTTP. For any production website, HTTPS is non-negotiable for user trust and SEO.

**Caching and timeout controls:** CloudFront gives you fine-grained control over how long content stays cached, when to invalidate cache, and how to handle different file types. This level of control doesn't exist with direct S3 access.

**DDoS protection and WAF integration:** CloudFront includes AWS Shield Standard for DDoS mitigation and can integrate with AWS WAF for advanced security rules. S3 alone doesn't provide these protections.

Think of CloudFront as a proxy layer that sits between users and your S3 bucket (the origin). Users never access S3 directly - they go through CloudFront which handles the routing, caching, and security. This architecture scales automatically regardless of traffic volume.

### Console Navigation vs Theory

I have four AWS certifications and have watched hours of theory lectures, but actually building in the AWS console is fundamentally different from watching someone else do it or answering multiple-choice questions. The console UI requires navigating tabs, scrolling to find specific settings, understanding which configurations live in Properties vs Permissions vs Management, and reading what AWS is telling you in real-time. Watching lectures provides theory. Building in the console provides practical skill. Both are necessary but they're not interchangeable.

### JSON Policy Format

Understanding policy structure is critical for AWS security. The JSON format initially seemed complex but breaking it into the five SEPAR components makes it manageable. Each policy statement needs to identify itself (Sid), declare whether it's allowing or denying (Effect), specify who it applies to (Principal), define what actions are permitted (Action), and identify which resources are affected (Resource). Once you understand this structure, you can read and write policies for any AWS service, not just S3.

## What I Would Do Differently Next Time

Now that I understand the architecture, my next iteration would include:

**Enhanced content:** Add an error.html page for 404 handling, include CSS styling, add images to test how CloudFront handles different file types and caching behaviors.

**Custom configurations:** Modify CloudFront timeout settings, experiment with cache behaviors for different file types, test invalidation when content updates.

**Multi-region exploration:** Replicate the bucket to a different region and compare latency from my location when accessing each region's S3 endpoint directly. This would demonstrate the regional nature of S3 versus the global nature of CloudFront.

**Custom domain with Route 53:** Instead of the auto-generated CloudFront domain (d3sow6jxmgyxlc.cloudfront.net), configure Route 53 to point a custom domain name to the distribution. This would involve purchasing a domain, creating a hosted zone in Route 53, and updating the CloudFront distribution with a CNAME record.

## Project Execution Notes

Total build time was under 30 minutes, with an additional 15-20 minutes waiting for CloudFront deployment to complete. I completed this project at the gym while waiting between sets, which proved that once you understand what you're building, the actual implementation is straightforward. The longest part of the entire process was simply waiting for CloudFront to propagate globally, which is unavoidable.

The speed of execution came from understanding the architecture conceptually before starting. Last night's planning session where I learned what S3 and CloudFront do and why they work together meant today I wasn't figuring out concepts while trying to click buttons. I knew my objective for each phase and just had to navigate the console to implement it.

## Significance of This Milestone

This project represents my first transition from student to practitioner. I'm no longer just learning about AWS - I'm building AWS infrastructure. The website at https://d3sow6jxmgyxlc.cloudfront.net/ is real, live, production-grade architecture accessible globally. When I show this to my mentor Andy, I'm showing him actual cloud infrastructure I built and can explain, not just theory I studied.

Six days ago I was learning terminal commands. Today I deployed a website to AWS with global CDN distribution and HTTPS security. The progression from foundational skills to hands-on building is exactly what this 90-day journey is designed to achieve. Week 1 built the foundation. Week 2 starts with me as a builder.

## Next Steps

Tomorrow I'll document this entire build process with screenshots and architecture diagrams for my GitHub repository. Monday begins Week 2 where I'll build on this foundation with more complex AWS projects involving EC2, VPC networking, and infrastructure automation. Each project will layer new services and concepts onto what I've already learned.

The goal isn't just to build projects - it's to understand AWS architecture patterns deeply enough to design solutions for real business problems. This S3+CloudFront pattern is one of dozens I'll master over the next 84 days.

---

**Days completed:** 6 of 90  
**Days remaining:** 84  
**Week 1 Status:** Complete ✅  
**First AWS Infrastructure:** S3 + CloudFront static website ✅  
**Target completion:** January 7, 2026

**Live website:** https://d3sow6jxmgyxlc.cloudfront.net/  
**GitHub repository:** https://github.com/Christapherson/aws-learning-journey
